{
    "contents": [
        {
            "heading": "Print Matrix in Spiral Order",
            "Body": "<div class=\"mt-6 ml-0 max-w-none md:ml-10 prose sm:prose-lg xl:prose-xl select-none\"><p>K-Nearest Neighbor is a Supervised Machine Learning algorithm that can be used to solve classification as well as regression problems. It is probably the first \"machine learning\" algorithm developed, and because of its simple nature, it is still widely accepted in solving many industrial problems. The unique thing about this algorithm is it learns but without explicitly mapping input variables to the target variables. In this article, we are going to understand this algorithm in detail.</p>\n<h2>Key Takeaways from this&nbsp;blog:</h2>\n<p>After going through this article, we will understand the following things:</p>\n<ol>\n<li>What is the KNN algorithm in Machine Learning?</li>\n<li>Why is KNN instance-based learning or a Lazy learner?</li>\n<li>Why KNN is a non-parametric algorithm?</li>\n<li>What are the common assumptions in KNN?</li>\n<li>How does KNN work?</li>\n<li>How the value of K affects the KNN algorithm?</li>\n<li>How does feature scaling affect KNN?</li>\n<li>What are the Voronoi cell and Voronoi diagrams?</li>\n<li>KNN for regression problems.</li>\n<li>Implementation of the KNN algorithm in python.</li>\n</ol>\n<p>So let's start without any further delay.</p>\n<h2>What is the KNN algorithm in Machine Learning?</h2>\n<p>In the introduction section, we already have explained KNN formally. Now, let's understand it in layman's terms. Some friends did not understand the concepts in our school days and still scored well in exams because of their memorization skills. We can correlate those friends with KNN. This ML algorithm does not follow the traditional approach of learning parameters from the training data and tries to fit a function. Instead, it memorizes the complete training data instances, and whenever a new test sample comes, it tries to verify the similarity of the test sample with its learned training samples.</p>\n<h2>Why is KNN instance-based learning or a Lazy&nbsp;learner?</h2>\n<p>Instance-based learning is also known as memory-based learning<strong>.</strong> Instead of explicit generalization, KNN compares new data samples with training data samples present in its memory.</p>\n<p>They are also called lazy algorithms, as any computation only happens when we receive new observations. Before accepting any test sample, it just memorizes everything in its memory and defers the calculations for the last like a lazy person.</p>\n<h2>Why KNN is a non-parametric algorithm?</h2>\n<p>KNN comes under the <strong><a href=\"https://www.enjoyalgorithms.com/blog/classification-of-machine-learning-models\">non-parametric algorithm</a></strong> category. Can we guess why? It is learning the complete training set, so if there are more instances in the future, the learning will change drastically. Hence learning is not dependent on the given data, which is a characteristic of a non-parametric algorithm.</p>\n<h2>What are the common assumptions in&nbsp;KNN?</h2>\n<p>This algorithm makes two major assumptions,</p>\n<ul>\n<li>Every sample part of the training data is mapped to real n-dimensional space. We can say that every sample will have the same dimension or number of attributes in simple terms.&nbsp;</li>\n<li>The \"nearest neighbors\" are defined in terms of <strong>Euclidean Distance</strong>, <strong>Manhattan Distance</strong>, or <strong>Hamming Distance</strong>. The choice of distance matters a lot and can change the prediction.</li>\n</ul>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/0*MBTyUQ648MfodIMb.png\" alt=\"Distance metrics\" title=\"Distance metrics\"></p>\n<h2><strong>Working of&nbsp;KNN</strong></h2>\n<p>Let's understand the stepwise analysis of this algorithm for any classification problem.</p>\n<p><strong>Step1:</strong> We first need to select the number of neighbors we want to consider. This is the term K in the KNN algorithm and highly affects the prediction.</p>\n<p><strong>Step2: We</strong> need to find the K neighbors based on any distance metric. It can be Euclidean, Manhatten, or our custom distance metric. We will have the test sample on which we want the prediction. The Closest K samples in the training data from this test sample will be our K neighbors.</p>\n<p><strong>Step3:</strong> Among the selected K neighbors, we need to count how many neighbors are from the different classes.&nbsp;</p>\n<p><strong>Step4:</strong> Now, we have to assign the test data sample to the class for which the count of neighbors was maximum.</p>\n<p>We performed the prediction in these four simple steps. In summary, the KNN algorithm at the training phase stores the dataset, and when it gets a new query, it classifies that query into a class similar to the existing query.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*-S8Zf-MufUStk1OEyEzuFQ.jpeg\" alt=\"1-NN vs. 4-NN \" title=\"1-NN vs. 4-NN\"></p>\n<p>Consider an example shown in the above image. Initially, the entire training dataset is considered and mapped in an R² space of positive and negative classes. The test case <strong>xq</strong> is then classified using 1-NN (1 neighbor) and 4-NN (4 neighbors) classifiers. The results for both are different, as we see that <strong>xq</strong> is classified as <strong>+ve for 1-NN</strong> and <strong>-ve for 4-NN.</strong>&nbsp;</p>\n<h2>How the value of K affects the KNN algorithm?</h2>\n<p>The value of K in the KNN algorithm can be anything ranging from 1 to the total number of samples. A small value of K means that the model is overfitting and is vulnerable to outliers. This model will have high variance and low bias. On the other hand, a model with a high value of K will have low variance and high bias and will result in underfitting. When we slowly increase the value of K from 1 to the number of training samples, the model will start smoothing the boundary surfaces.</p>\n<p><strong>K = 1:</strong> A model with K=1 will have 0 training error and hard boundaries for determining the class of test query.</p>\n<p><strong>K = len(sample data):</strong> This model will be highly biased towards the majority class (with a higher number of samples) and less accurate.</p>\n<p><strong>Note:</strong> Keeping the K values as odd is advisable to reduce the chances of getting a tie.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*7yP2rK3WSNvw_rSXecvPnQ.jpeg\"></p>\n<h2>How does feature scaling affect&nbsp;KNN?</h2>\n<p>KNN depends highly on the distance between data samples; hence scaling plays a vital role here. Suppose we train the KNN algorithm on unscaled data. There can be a case where different attributes lie in various scales, making our model biased towards the features with lesser magnitude values. To avoid that, it is always advisable to standardize the attributes before applying the KNN algorithm. Please look at <a href=\"https://www.enjoyalgorithms.com/blog/need-of-feature-scaling-in-machine-learning\">this blog</a> to visualize how distance calculation can be affected by scaling for a better understanding.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/0*-tv0vjTEud6hDKWn.png\" alt=\"Source: Scikit-learn.org, Scaling affect KNN \" title=\"Scaling affect KNN \"></p>\n<h2>What are the Voronoi cell and Voronoi diagrams?</h2>\n<p>Other ML algorithms like linear regression, logistic regression, and SVMs try to fit a mapping function from input to output. This mapping function is also known as the <strong>Hypothesis function</strong>. But, KNN is different. It does not form any explicit Hypothesis function, but it does create a hypothesis space. For a dataset in R², the hypothesis space is a polyhedron formed using the training samples. Let's first understand what Voronoi cell is.</p>\n<h3><strong>What is Voronoi&nbsp;Cell?</strong></h3>\n<p>Suppose the training set is \"T\" and the elements of that training set are \"x\"<strong>.</strong> Then Voronoi Cell of <strong>xi</strong> is a polytope (a geometric shape with \"flat\" sides) consisting of all points closer to <strong>xi</strong> than any other points in <strong>T.</strong></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*vvDVXsv2ulT_-IaikeAXNg.jpeg\" alt=\"Voronoi Cell and polytope\" title=\"Voronoi Cell and polytope\"></p>\n<p>If we observe in the above image, initially, every cell contains a single sample which means K = 0, and as we increase the value of K, two cells merge and form a new polytope including K samples. Voronoi Cells cover the entire training space of T, and when we combine all of these cells, it will create Voronoi Diagram.</p>\n<h2>KNN for Regression problems</h2>\n<p>So far, we have discussed how we could use the KNN algorithm to solve the classification tasks, but this machine learning algorithm can also solve regression problems. We need to tweak the approach slightly. Instead of counting the <strong>K</strong> nearest neighbor class labels, what if we average the data over K neighbors<strong><em>.</em></strong> Yes! It will act as the regression model in such a scenario.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*RWeDQNYq_K3bLqA6K3ni1A.jpeg\">k-NN for Regression tasks</p>\n<p>For example, let's say we have a test data X for which we want to predict the continuous variable Y. Suppose we have finalized that our neighbors can only be 3 (i.e., K=3). Three neighbors from the training data are:</p>\n<p>X1 → Y1, X2 → Y2, X3 → Y3. We should be clear that KNN is a supervised learning algorithm, and hence we will always have the corresponding labels for the input variables while training. At the time of prediction, we can average out the three labels to find the corresponding label of the test data. For example, Y = (Y1 + Y2 + Y3)/3. This averaging can be replaced with other techniques like median, mode, or any custom approach.&nbsp;</p>\n<h2>Strengths of KNN algorithm</h2>\n<p>KNN is a very famous algorithm because of its simplicity, so let's understand the key strengths.&nbsp;</p>\n<ol>\n<li><strong>Zero training time:</strong> A very little training time is required compared to the other machine learning algorithms.</li>\n<li><strong>Sample efficiency:</strong> There is no need for a very high training sample.</li>\n<li><strong>Explainable:</strong> At each step, the reason for the prediction can easily be depicted. Such explainability is rare.</li>\n<li><strong>Easy to add and remove the data:</strong> For other machine learning models, data addition requires retraining of the model. While in KNN, we can directly update the memory and perform the inference.</li>\n<li><strong>Less sensitive to class imbalance:</strong> Suppose we have two classes and one class has significantly higher instances in the dataset than others. KNN, unlike other ML algorithms, is least affected by such class imbalances.</li>\n</ol>\n<h2>Disadvantages of k-NN algorithm</h2>\n<p>No doubt, KNN is cool, but this algorithm has some limitations. It is not the first choice among Machine Learning experts, and the reasons are:</p>\n<ol>\n<li><strong>Needs a lot of storage:</strong> KNN stores the whole training data in its memory and performs inference based on that. It makes the algorithm unemployable on edge platforms.</li>\n<li><strong>Predictions are Slow:</strong> The time complexity of KNN is O(dN), where <strong>d</strong> is the dimension or number of features and <strong>N</strong> is the total number of samples. More the data more will be the prediction time.</li>\n<li><strong>Irrelevant features can fool the nearest neighbors.</strong></li>\n</ol>\n<h2><strong>KNN Implementation in Python using&nbsp;sklearn</strong></h2>\n<p>Too much theory! Let's implement the KNN algorithm in python to solve a classification problem.&nbsp;</p>\n<h3><strong>Step 1: Import the necessary dataset libraries.</strong></h3>\n<p>The dataset used to implement KNN is the famous Iris dataset imported from the Scikit-learn datasets as load_iris. Other libraries are imported for training, preprocessing, and evaluation.</p>\n<pre><code class=\"language-python\">import matplotlib.pyplot as plt   # update the plot \nfrom sklearn import datasets# read the data \nimport numpy as np #for arrays \nfrom sklearn.model_selection import train_test_split # split the data \nfrom sklearn.preprocessing import StandardScaler # scale the data \nfrom sklearn.neighbors import KNeighborsClassifier # the algorithm \n\nfrom sklearn.metrics import accuracy_score  #grade the results \nimport pandas as pd \n\niris = datasets.load_iris() # read the data \n\nX = iris.data[:]  # select the features to use \ny = iris.target   # select the classes\n\n\niris_dataframe = pd.DataFrame (data= np.c_[iris['data'], iris['target']],\n\n    columns= iris['feature_names'] + ['target'])\n\nplt.figure(2)\ngrr = pd.plotting.scatter_matrix(iris_dataframe,\n                                  c=iris[\"target\"], \n                                  figsize=(15, 15),\n                                  marker='o', \n                                  S=60,\n                                  alpha=.8)\nplt.show(2)\n</code></pre>\n<h3>Step 2: Understanding the&nbsp;data</h3>\n<p>This dataset has four variables: <strong>sepal length, sepal width, petal length, and petal width,</strong> describing iris plants of three types: <strong>Setosa, Versicolour,</strong> and <strong>Virginica</strong>. The dataset contains 150 observations, with each observation labeled as the actual type of the plant.&nbsp;</p>\n<h3>Step 3: Visualization</h3>\n<p>The dataset, which has four dimensions, is visualized pairwise to distinguish them. The pairwise scatter plot matrix of the iris data set helps visualize the relationship among multiple variables separately within subdivisions of the dataset. In the image below, <strong>violet</strong> color represents <strong>Setosa</strong>, <strong>green</strong> represents <strong>Versicolour</strong>, and <strong>yellow</strong> represents <strong>Virginica</strong>.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*L4b2d0tYFWeEkcDuajgZyw.jpeg\" alt=\"Pairwise comparison for different features\" title=\"Pairwise comparison for different features\"></p>\n<h3><strong>Step 4: Data Preprocessing</strong></h3>\n<p>The entire dataset is initially split into the training and testing part using the train<em>test</em>split function of Scikit-learn. A standard scaler is used in the next step, StandardScalar( ), to standardize the data (column-wise). When fit to a dataset, the function will transform the dataset to <strong>mean μ = 0</strong> and <strong>standard deviation σ = 1.</strong></p>\n<p>A dataset with having N samples and m features,</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*L_Q44QKznAFWYejvWXyKoQ.png\" alt=\"Distance Calculation\" title=\"Distance Calculation\"></p>\n<p>Thus every data is then updated as,</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*UkLkymXlo54_RbAseOBr1Q.png\" alt=\"Standardization\" title=\"Standardization\"></p>\n<pre><code class=\"language-python\">X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.25,random_state=0)\n\n\nSC = StandardScaler()# create the standard scaler \nsc.fit(X_train) # fit to the training data \nx_train_std = sc.transform(X_train) # transform the training data \nX_test_std = sc.transform(X_test) # same transformation on test data\n</code></pre>\n<h3><strong>Step 5: Model Fitting and Evaluation</strong></h3>\n<p>We will fit the KNN model for different values of K ranging between 1 to the number of samples in the testing dataset. The metric <strong>\"Minkowski\"</strong> along with <strong>p = 2</strong> represents the Euclidean distance in the R-space. The model will be fitted on different values of K and then is used to predict the output for a test sample size.</p>\n<pre><code class=\"language-python\">accuracyTest = {}; accuracy Train = {} \n\nfor k in range (len (y_test):\n\n    knn = KNeighborsClassifier(n_neighbors=k+1, p=2, metric='minkowski')\n    knn.fit(X_train_std,y_train)\n    y_pred = knn.predict(x_test_std) \n    y_train_pred = knn.predict(X_train_std) \n\n    if (k+1)%10==0:\n        print(10*'-')\n        print(\"For k = %s\" %(k+1))\n        print('Number in test ', len(y_test))\n        print('Misclassified samples: %d' % (y_test != y_pred).sum())\n\n    accTrain = accuracy_score(y_train,y_train_pred)\n    acc = accuracy_score(y_test, y_pred)\n    accuracyTest[k+1] = acc\n    accuracyTrain[k+1] = accTrain\n\nfor accuracy in [accuracy Train, accuracy Test]:\n    lists = sorted(accuracy.items() # sorted by key, return a list of tuples \n    X, y = zip(*lists) # unpack a list of pairs into two tuples \n    plt.plot(x, y)\n    plt.show()\n</code></pre>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*2w5zsVeff7Ob1tMp4p8E2Q.png\" alt=\"Training and Testing accuracy\" title=\"Training and Testing accuracy\"></p>\n<p>If we give priority to the testing accuracy, the value of K &gt; 18 decreases the testing accuracy sharply. So we can say that the optimal number of neighbors can be around 15 to 18.</p>\n<h2><strong>Decision Boundaries for&nbsp;KNN</strong></h2>\n<p>The two datasets (training and testing) are combined to show the effect of varying K in the KNN algorithm. Only two features (petal length and petal width) are considered for visualization. The value of K taken is [1,25,50,75,100,112], where the training sample size is 112. The decision boundary at K = 112 returns the majority of the three classes, which is red.</p>\n<pre><code class=\"language-python\">X = iris.data[:, [2,3]] # select the features to use \ny = iris.target         # select the classes\n\nX_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.25,random_state=0)\n\n\nSC = StandardScaler()# create the standard scaler \nsc.fit(X_train) # fit to the training data \nx_train_std = sc.transform(X_train) # transform the training data \nX_test_std = sc.transform(X_test) # same transformation on test data\n\nX_combined_std = np.vstack((X_train_std, X_test_std))\ny_combined = np.hstack((y_train, y_test))\n\nprint('Number in combined ', len(y_combined))\n# check results on combined data \ny_combined_pred = knn.predict(X_combined_std)\n\nprint('Misclassified combined samples: %d' 1 % (y_combined != y combined_pred). sum )\nprint('Combined Accuracy: %.2f' % accuracy_score(y_combined, y_combined_pred)) \n# visualize the results \n\nfor k in [1,25,50, 100, len(X_train)]:\n\n    knn = KNeighborsClassifier (n_neighbors=k, p=2, metric='minkowski')\n\n    knn.fit(X_train_std, y_train) \n\n    plot_decision_regions(X=X_combined_std, y=y_combined, classifier=knn,\n                                test_idx=range(105,150))\n\n    plt.xlabel('petal length [standardized]') \n    plt.ylabel('petal width [standardized]') \n    plt.title('k=%s'%k) \n    plt.legend(loc='upper left') \n    plt.show()\n</code></pre>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*VXDGlFehAYqClSiAbsApSQ.jpeg\" alt=\"Decision boundary\" title=\"Decision boundary\"></p>\n<h2>Industrial Applications of&nbsp;KNN</h2>\n<p>Although there are certain limitations, this algorithm is widely used in industries because of its simplicity. Some of these applications are:</p>\n<ol>\n<li><strong>Email spam filtering:</strong> For detecting the trivial and fixed types of spam emails, KNN can perform well. The implementation steps of this algorithm can be found <a href=\"https://www.enjoyalgorithms.com/blog/email-spam-and-non-spam-filtering-using-machine-learning\">here</a>.</li>\n<li><strong>Wine Quality prediction:</strong> Wine quality prediction is a regression task and can be solved using the KNN algorithm. The implementation can be found <a href=\"https://www.enjoyalgorithms.com/blog/wine-quality-prediction\">here</a>.</li>\n<li><strong>Recommendation system:</strong> KNN is used to build the recommendation engines that recommend some products/movies/songs to the users based on their likings or disliking.&nbsp;</li>\n</ol>\n<h2>Possible Interview Questions</h2>\n<p>As we stated, this algorithm brings a lot of explainability with itself. Interviewers can ask more profound questions on this topic. Some of them could be,</p>\n<ol>\n<li>How k-NN is different from other Machine Learning algorithms?</li>\n<li>Will changing the distance metric affect the classification accuracy?</li>\n<li>Is k-NN highly sensitive to data normalization?&nbsp;</li>\n<li>Why is it a non-parametric algorithm?</li>\n<li>What are the major cons of the k-NN algorithm?</li>\n</ol>\n<h2>Conclusion</h2>\n<p>In this article, we have covered the concept of the first \"Machine Learning\" algorithm, i.e., KNearest Neighbour. We saw how we can define the instances as neighbors and how the value of K affects the predictions. We also discussed why feature scaling played a vital role and learned about the Voronoi Diagram. After that, we discussed the regression use-case of KNN. Finally, we implemented the KNN algorithm on the famous Iris dataset. We hope you enjoyed the article.</p>\n<h4>References</h4>\n<ol>\n<li><a href=\"http://jmlr.csail.mit.edu/papers/v12/pedregosa11a.html\">Scikit-learn: Machine Learning in Python</a>, Pedregosa, <em>et al.</em>, JMLR 12, pp. 2825–2830, 2011</li>\n<li>Mitchell, T. M. (1997). Machine learning., McGraw Hill series in computer science New York: McGraw-Hill.</li>\n<li>UCI Machine Learning Repository: Iris Data Set.</li>\n<li>J. D. Hunter, “Matplotlib: A 2D Graphics Environment”, Computing in Science &amp; Engineering, vol. 9, no. 3, pp. 90–95, 2007.</li>\n</ol>\n<h4>Enjoy Learning! Enjoy Algorithms!</h4></div>",
        "createdAt": "2022-02-24T07:45:46.825Z",
        "updatedAt": "2022-02-26T19:27:02.372Z",
        "publishedAt": "2022-02-24T07:46:12.600Z"
        },
        {
            "heading": "Print Matrix in Spiral Order",
            "Body": "<div class=\"mt-6 ml-0 max-w-none md:ml-10 prose sm:prose-lg xl:prose-xl select-none\"><p>K-Nearest Neighbor is a Supervised Machine Learning algorithm that can be used to solve classification as well as regression problems. It is probably the first \"machine learning\" algorithm developed, and because of its simple nature, it is still widely accepted in solving many industrial problems. The unique thing about this algorithm is it learns but without explicitly mapping input variables to the target variables. In this article, we are going to understand this algorithm in detail.</p>\n<h2>Key Takeaways from this&nbsp;blog:</h2>\n<p>After going through this article, we will understand the following things:</p>\n<ol>\n<li>What is the KNN algorithm in Machine Learning?</li>\n<li>Why is KNN instance-based learning or a Lazy learner?</li>\n<li>Why KNN is a non-parametric algorithm?</li>\n<li>What are the common assumptions in KNN?</li>\n<li>How does KNN work?</li>\n<li>How the value of K affects the KNN algorithm?</li>\n<li>How does feature scaling affect KNN?</li>\n<li>What are the Voronoi cell and Voronoi diagrams?</li>\n<li>KNN for regression problems.</li>\n<li>Implementation of the KNN algorithm in python.</li>\n</ol>\n<p>So let's start without any further delay.</p>\n<h2>What is the KNN algorithm in Machine Learning?</h2>\n<p>In the introduction section, we already have explained KNN formally. Now, let's understand it in layman's terms. Some friends did not understand the concepts in our school days and still scored well in exams because of their memorization skills. We can correlate those friends with KNN. This ML algorithm does not follow the traditional approach of learning parameters from the training data and tries to fit a function. Instead, it memorizes the complete training data instances, and whenever a new test sample comes, it tries to verify the similarity of the test sample with its learned training samples.</p>\n<h2>Why is KNN instance-based learning or a Lazy&nbsp;learner?</h2>\n<p>Instance-based learning is also known as memory-based learning<strong>.</strong> Instead of explicit generalization, KNN compares new data samples with training data samples present in its memory.</p>\n<p>They are also called lazy algorithms, as any computation only happens when we receive new observations. Before accepting any test sample, it just memorizes everything in its memory and defers the calculations for the last like a lazy person.</p>\n<h2>Why KNN is a non-parametric algorithm?</h2>\n<p>KNN comes under the <strong><a href=\"https://www.enjoyalgorithms.com/blog/classification-of-machine-learning-models\">non-parametric algorithm</a></strong> category. Can we guess why? It is learning the complete training set, so if there are more instances in the future, the learning will change drastically. Hence learning is not dependent on the given data, which is a characteristic of a non-parametric algorithm.</p>\n<h2>What are the common assumptions in&nbsp;KNN?</h2>\n<p>This algorithm makes two major assumptions,</p>\n<ul>\n<li>Every sample part of the training data is mapped to real n-dimensional space. We can say that every sample will have the same dimension or number of attributes in simple terms.&nbsp;</li>\n<li>The \"nearest neighbors\" are defined in terms of <strong>Euclidean Distance</strong>, <strong>Manhattan Distance</strong>, or <strong>Hamming Distance</strong>. The choice of distance matters a lot and can change the prediction.</li>\n</ul>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/0*MBTyUQ648MfodIMb.png\" alt=\"Distance metrics\" title=\"Distance metrics\"></p>\n<h2><strong>Working of&nbsp;KNN</strong></h2>\n<p>Let's understand the stepwise analysis of this algorithm for any classification problem.</p>\n<p><strong>Step1:</strong> We first need to select the number of neighbors we want to consider. This is the term K in the KNN algorithm and highly affects the prediction.</p>\n<p><strong>Step2: We</strong> need to find the K neighbors based on any distance metric. It can be Euclidean, Manhatten, or our custom distance metric. We will have the test sample on which we want the prediction. The Closest K samples in the training data from this test sample will be our K neighbors.</p>\n<p><strong>Step3:</strong> Among the selected K neighbors, we need to count how many neighbors are from the different classes.&nbsp;</p>\n<p><strong>Step4:</strong> Now, we have to assign the test data sample to the class for which the count of neighbors was maximum.</p>\n<p>We performed the prediction in these four simple steps. In summary, the KNN algorithm at the training phase stores the dataset, and when it gets a new query, it classifies that query into a class similar to the existing query.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*-S8Zf-MufUStk1OEyEzuFQ.jpeg\" alt=\"1-NN vs. 4-NN \" title=\"1-NN vs. 4-NN\"></p>\n<p>Consider an example shown in the above image. Initially, the entire training dataset is considered and mapped in an R² space of positive and negative classes. The test case <strong>xq</strong> is then classified using 1-NN (1 neighbor) and 4-NN (4 neighbors) classifiers. The results for both are different, as we see that <strong>xq</strong> is classified as <strong>+ve for 1-NN</strong> and <strong>-ve for 4-NN.</strong>&nbsp;</p>\n<h2>How the value of K affects the KNN algorithm?</h2>\n<p>The value of K in the KNN algorithm can be anything ranging from 1 to the total number of samples. A small value of K means that the model is overfitting and is vulnerable to outliers. This model will have high variance and low bias. On the other hand, a model with a high value of K will have low variance and high bias and will result in underfitting. When we slowly increase the value of K from 1 to the number of training samples, the model will start smoothing the boundary surfaces.</p>\n<p><strong>K = 1:</strong> A model with K=1 will have 0 training error and hard boundaries for determining the class of test query.</p>\n<p><strong>K = len(sample data):</strong> This model will be highly biased towards the majority class (with a higher number of samples) and less accurate.</p>\n<p><strong>Note:</strong> Keeping the K values as odd is advisable to reduce the chances of getting a tie.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*7yP2rK3WSNvw_rSXecvPnQ.jpeg\"></p>\n<h2>How does feature scaling affect&nbsp;KNN?</h2>\n<p>KNN depends highly on the distance between data samples; hence scaling plays a vital role here. Suppose we train the KNN algorithm on unscaled data. There can be a case where different attributes lie in various scales, making our model biased towards the features with lesser magnitude values. To avoid that, it is always advisable to standardize the attributes before applying the KNN algorithm. Please look at <a href=\"https://www.enjoyalgorithms.com/blog/need-of-feature-scaling-in-machine-learning\">this blog</a> to visualize how distance calculation can be affected by scaling for a better understanding.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/0*-tv0vjTEud6hDKWn.png\" alt=\"Source: Scikit-learn.org, Scaling affect KNN \" title=\"Scaling affect KNN \"></p>\n<h2>What are the Voronoi cell and Voronoi diagrams?</h2>\n<p>Other ML algorithms like linear regression, logistic regression, and SVMs try to fit a mapping function from input to output. This mapping function is also known as the <strong>Hypothesis function</strong>. But, KNN is different. It does not form any explicit Hypothesis function, but it does create a hypothesis space. For a dataset in R², the hypothesis space is a polyhedron formed using the training samples. Let's first understand what Voronoi cell is.</p>\n<h3><strong>What is Voronoi&nbsp;Cell?</strong></h3>\n<p>Suppose the training set is \"T\" and the elements of that training set are \"x\"<strong>.</strong> Then Voronoi Cell of <strong>xi</strong> is a polytope (a geometric shape with \"flat\" sides) consisting of all points closer to <strong>xi</strong> than any other points in <strong>T.</strong></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*vvDVXsv2ulT_-IaikeAXNg.jpeg\" alt=\"Voronoi Cell and polytope\" title=\"Voronoi Cell and polytope\"></p>\n<p>If we observe in the above image, initially, every cell contains a single sample which means K = 0, and as we increase the value of K, two cells merge and form a new polytope including K samples. Voronoi Cells cover the entire training space of T, and when we combine all of these cells, it will create Voronoi Diagram.</p>\n<h2>KNN for Regression problems</h2>\n<p>So far, we have discussed how we could use the KNN algorithm to solve the classification tasks, but this machine learning algorithm can also solve regression problems. We need to tweak the approach slightly. Instead of counting the <strong>K</strong> nearest neighbor class labels, what if we average the data over K neighbors<strong><em>.</em></strong> Yes! It will act as the regression model in such a scenario.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*RWeDQNYq_K3bLqA6K3ni1A.jpeg\">k-NN for Regression tasks</p>\n<p>For example, let's say we have a test data X for which we want to predict the continuous variable Y. Suppose we have finalized that our neighbors can only be 3 (i.e., K=3). Three neighbors from the training data are:</p>\n<p>X1 → Y1, X2 → Y2, X3 → Y3. We should be clear that KNN is a supervised learning algorithm, and hence we will always have the corresponding labels for the input variables while training. At the time of prediction, we can average out the three labels to find the corresponding label of the test data. For example, Y = (Y1 + Y2 + Y3)/3. This averaging can be replaced with other techniques like median, mode, or any custom approach.&nbsp;</p>\n<h2>Strengths of KNN algorithm</h2>\n<p>KNN is a very famous algorithm because of its simplicity, so let's understand the key strengths.&nbsp;</p>\n<ol>\n<li><strong>Zero training time:</strong> A very little training time is required compared to the other machine learning algorithms.</li>\n<li><strong>Sample efficiency:</strong> There is no need for a very high training sample.</li>\n<li><strong>Explainable:</strong> At each step, the reason for the prediction can easily be depicted. Such explainability is rare.</li>\n<li><strong>Easy to add and remove the data:</strong> For other machine learning models, data addition requires retraining of the model. While in KNN, we can directly update the memory and perform the inference.</li>\n<li><strong>Less sensitive to class imbalance:</strong> Suppose we have two classes and one class has significantly higher instances in the dataset than others. KNN, unlike other ML algorithms, is least affected by such class imbalances.</li>\n</ol>\n<h2>Disadvantages of k-NN algorithm</h2>\n<p>No doubt, KNN is cool, but this algorithm has some limitations. It is not the first choice among Machine Learning experts, and the reasons are:</p>\n<ol>\n<li><strong>Needs a lot of storage:</strong> KNN stores the whole training data in its memory and performs inference based on that. It makes the algorithm unemployable on edge platforms.</li>\n<li><strong>Predictions are Slow:</strong> The time complexity of KNN is O(dN), where <strong>d</strong> is the dimension or number of features and <strong>N</strong> is the total number of samples. More the data more will be the prediction time.</li>\n<li><strong>Irrelevant features can fool the nearest neighbors.</strong></li>\n</ol>\n<h2><strong>KNN Implementation in Python using&nbsp;sklearn</strong></h2>\n<p>Too much theory! Let's implement the KNN algorithm in python to solve a classification problem.&nbsp;</p>\n<h3><strong>Step 1: Import the necessary dataset libraries.</strong></h3>\n<p>The dataset used to implement KNN is the famous Iris dataset imported from the Scikit-learn datasets as load_iris. Other libraries are imported for training, preprocessing, and evaluation.</p>\n<pre><code class=\"language-python\">import matplotlib.pyplot as plt   # update the plot \nfrom sklearn import datasets# read the data \nimport numpy as np #for arrays \nfrom sklearn.model_selection import train_test_split # split the data \nfrom sklearn.preprocessing import StandardScaler # scale the data \nfrom sklearn.neighbors import KNeighborsClassifier # the algorithm \n\nfrom sklearn.metrics import accuracy_score  #grade the results \nimport pandas as pd \n\niris = datasets.load_iris() # read the data \n\nX = iris.data[:]  # select the features to use \ny = iris.target   # select the classes\n\n\niris_dataframe = pd.DataFrame (data= np.c_[iris['data'], iris['target']],\n\n    columns= iris['feature_names'] + ['target'])\n\nplt.figure(2)\ngrr = pd.plotting.scatter_matrix(iris_dataframe,\n                                  c=iris[\"target\"], \n                                  figsize=(15, 15),\n                                  marker='o', \n                                  S=60,\n                                  alpha=.8)\nplt.show(2)\n</code></pre>\n<h3>Step 2: Understanding the&nbsp;data</h3>\n<p>This dataset has four variables: <strong>sepal length, sepal width, petal length, and petal width,</strong> describing iris plants of three types: <strong>Setosa, Versicolour,</strong> and <strong>Virginica</strong>. The dataset contains 150 observations, with each observation labeled as the actual type of the plant.&nbsp;</p>\n<h3>Step 3: Visualization</h3>\n<p>The dataset, which has four dimensions, is visualized pairwise to distinguish them. The pairwise scatter plot matrix of the iris data set helps visualize the relationship among multiple variables separately within subdivisions of the dataset. In the image below, <strong>violet</strong> color represents <strong>Setosa</strong>, <strong>green</strong> represents <strong>Versicolour</strong>, and <strong>yellow</strong> represents <strong>Virginica</strong>.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*L4b2d0tYFWeEkcDuajgZyw.jpeg\" alt=\"Pairwise comparison for different features\" title=\"Pairwise comparison for different features\"></p>\n<h3><strong>Step 4: Data Preprocessing</strong></h3>\n<p>The entire dataset is initially split into the training and testing part using the train<em>test</em>split function of Scikit-learn. A standard scaler is used in the next step, StandardScalar( ), to standardize the data (column-wise). When fit to a dataset, the function will transform the dataset to <strong>mean μ = 0</strong> and <strong>standard deviation σ = 1.</strong></p>\n<p>A dataset with having N samples and m features,</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*L_Q44QKznAFWYejvWXyKoQ.png\" alt=\"Distance Calculation\" title=\"Distance Calculation\"></p>\n<p>Thus every data is then updated as,</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*UkLkymXlo54_RbAseOBr1Q.png\" alt=\"Standardization\" title=\"Standardization\"></p>\n<pre><code class=\"language-python\">X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.25,random_state=0)\n\n\nSC = StandardScaler()# create the standard scaler \nsc.fit(X_train) # fit to the training data \nx_train_std = sc.transform(X_train) # transform the training data \nX_test_std = sc.transform(X_test) # same transformation on test data\n</code></pre>\n<h3><strong>Step 5: Model Fitting and Evaluation</strong></h3>\n<p>We will fit the KNN model for different values of K ranging between 1 to the number of samples in the testing dataset. The metric <strong>\"Minkowski\"</strong> along with <strong>p = 2</strong> represents the Euclidean distance in the R-space. The model will be fitted on different values of K and then is used to predict the output for a test sample size.</p>\n<pre><code class=\"language-python\">accuracyTest = {}; accuracy Train = {} \n\nfor k in range (len (y_test):\n\n    knn = KNeighborsClassifier(n_neighbors=k+1, p=2, metric='minkowski')\n    knn.fit(X_train_std,y_train)\n    y_pred = knn.predict(x_test_std) \n    y_train_pred = knn.predict(X_train_std) \n\n    if (k+1)%10==0:\n        print(10*'-')\n        print(\"For k = %s\" %(k+1))\n        print('Number in test ', len(y_test))\n        print('Misclassified samples: %d' % (y_test != y_pred).sum())\n\n    accTrain = accuracy_score(y_train,y_train_pred)\n    acc = accuracy_score(y_test, y_pred)\n    accuracyTest[k+1] = acc\n    accuracyTrain[k+1] = accTrain\n\nfor accuracy in [accuracy Train, accuracy Test]:\n    lists = sorted(accuracy.items() # sorted by key, return a list of tuples \n    X, y = zip(*lists) # unpack a list of pairs into two tuples \n    plt.plot(x, y)\n    plt.show()\n</code></pre>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*2w5zsVeff7Ob1tMp4p8E2Q.png\" alt=\"Training and Testing accuracy\" title=\"Training and Testing accuracy\"></p>\n<p>If we give priority to the testing accuracy, the value of K &gt; 18 decreases the testing accuracy sharply. So we can say that the optimal number of neighbors can be around 15 to 18.</p>\n<h2><strong>Decision Boundaries for&nbsp;KNN</strong></h2>\n<p>The two datasets (training and testing) are combined to show the effect of varying K in the KNN algorithm. Only two features (petal length and petal width) are considered for visualization. The value of K taken is [1,25,50,75,100,112], where the training sample size is 112. The decision boundary at K = 112 returns the majority of the three classes, which is red.</p>\n<pre><code class=\"language-python\">X = iris.data[:, [2,3]] # select the features to use \ny = iris.target         # select the classes\n\nX_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.25,random_state=0)\n\n\nSC = StandardScaler()# create the standard scaler \nsc.fit(X_train) # fit to the training data \nx_train_std = sc.transform(X_train) # transform the training data \nX_test_std = sc.transform(X_test) # same transformation on test data\n\nX_combined_std = np.vstack((X_train_std, X_test_std))\ny_combined = np.hstack((y_train, y_test))\n\nprint('Number in combined ', len(y_combined))\n# check results on combined data \ny_combined_pred = knn.predict(X_combined_std)\n\nprint('Misclassified combined samples: %d' 1 % (y_combined != y combined_pred). sum )\nprint('Combined Accuracy: %.2f' % accuracy_score(y_combined, y_combined_pred)) \n# visualize the results \n\nfor k in [1,25,50, 100, len(X_train)]:\n\n    knn = KNeighborsClassifier (n_neighbors=k, p=2, metric='minkowski')\n\n    knn.fit(X_train_std, y_train) \n\n    plot_decision_regions(X=X_combined_std, y=y_combined, classifier=knn,\n                                test_idx=range(105,150))\n\n    plt.xlabel('petal length [standardized]') \n    plt.ylabel('petal width [standardized]') \n    plt.title('k=%s'%k) \n    plt.legend(loc='upper left') \n    plt.show()\n</code></pre>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*VXDGlFehAYqClSiAbsApSQ.jpeg\" alt=\"Decision boundary\" title=\"Decision boundary\"></p>\n<h2>Industrial Applications of&nbsp;KNN</h2>\n<p>Although there are certain limitations, this algorithm is widely used in industries because of its simplicity. Some of these applications are:</p>\n<ol>\n<li><strong>Email spam filtering:</strong> For detecting the trivial and fixed types of spam emails, KNN can perform well. The implementation steps of this algorithm can be found <a href=\"https://www.enjoyalgorithms.com/blog/email-spam-and-non-spam-filtering-using-machine-learning\">here</a>.</li>\n<li><strong>Wine Quality prediction:</strong> Wine quality prediction is a regression task and can be solved using the KNN algorithm. The implementation can be found <a href=\"https://www.enjoyalgorithms.com/blog/wine-quality-prediction\">here</a>.</li>\n<li><strong>Recommendation system:</strong> KNN is used to build the recommendation engines that recommend some products/movies/songs to the users based on their likings or disliking.&nbsp;</li>\n</ol>\n<h2>Possible Interview Questions</h2>\n<p>As we stated, this algorithm brings a lot of explainability with itself. Interviewers can ask more profound questions on this topic. Some of them could be,</p>\n<ol>\n<li>How k-NN is different from other Machine Learning algorithms?</li>\n<li>Will changing the distance metric affect the classification accuracy?</li>\n<li>Is k-NN highly sensitive to data normalization?&nbsp;</li>\n<li>Why is it a non-parametric algorithm?</li>\n<li>What are the major cons of the k-NN algorithm?</li>\n</ol>\n<h2>Conclusion</h2>\n<p>In this article, we have covered the concept of the first \"Machine Learning\" algorithm, i.e., KNearest Neighbour. We saw how we can define the instances as neighbors and how the value of K affects the predictions. We also discussed why feature scaling played a vital role and learned about the Voronoi Diagram. After that, we discussed the regression use-case of KNN. Finally, we implemented the KNN algorithm on the famous Iris dataset. We hope you enjoyed the article.</p>\n<h4>References</h4>\n<ol>\n<li><a href=\"http://jmlr.csail.mit.edu/papers/v12/pedregosa11a.html\">Scikit-learn: Machine Learning in Python</a>, Pedregosa, <em>et al.</em>, JMLR 12, pp. 2825–2830, 2011</li>\n<li>Mitchell, T. M. (1997). Machine learning., McGraw Hill series in computer science New York: McGraw-Hill.</li>\n<li>UCI Machine Learning Repository: Iris Data Set.</li>\n<li>J. D. Hunter, “Matplotlib: A 2D Graphics Environment”, Computing in Science &amp; Engineering, vol. 9, no. 3, pp. 90–95, 2007.</li>\n</ol>\n<h4>Enjoy Learning! Enjoy Algorithms!</h4></div>",
        "createdAt": "2022-02-24T07:45:46.825Z",
        "updatedAt": "2022-02-26T19:27:02.372Z",
        "publishedAt": "2022-02-24T07:46:12.600Z"
        },
        {
            "heading": "Print Matrix in Spiral Order",
            "Body": "<div class=\"mt-6 ml-0 max-w-none md:ml-10 prose sm:prose-lg xl:prose-xl select-none\"><p>K-Nearest Neighbor is a Supervised Machine Learning algorithm that can be used to solve classification as well as regression problems. It is probably the first \"machine learning\" algorithm developed, and because of its simple nature, it is still widely accepted in solving many industrial problems. The unique thing about this algorithm is it learns but without explicitly mapping input variables to the target variables. In this article, we are going to understand this algorithm in detail.</p>\n<h2>Key Takeaways from this&nbsp;blog:</h2>\n<p>After going through this article, we will understand the following things:</p>\n<ol>\n<li>What is the KNN algorithm in Machine Learning?</li>\n<li>Why is KNN instance-based learning or a Lazy learner?</li>\n<li>Why KNN is a non-parametric algorithm?</li>\n<li>What are the common assumptions in KNN?</li>\n<li>How does KNN work?</li>\n<li>How the value of K affects the KNN algorithm?</li>\n<li>How does feature scaling affect KNN?</li>\n<li>What are the Voronoi cell and Voronoi diagrams?</li>\n<li>KNN for regression problems.</li>\n<li>Implementation of the KNN algorithm in python.</li>\n</ol>\n<p>So let's start without any further delay.</p>\n<h2>What is the KNN algorithm in Machine Learning?</h2>\n<p>In the introduction section, we already have explained KNN formally. Now, let's understand it in layman's terms. Some friends did not understand the concepts in our school days and still scored well in exams because of their memorization skills. We can correlate those friends with KNN. This ML algorithm does not follow the traditional approach of learning parameters from the training data and tries to fit a function. Instead, it memorizes the complete training data instances, and whenever a new test sample comes, it tries to verify the similarity of the test sample with its learned training samples.</p>\n<h2>Why is KNN instance-based learning or a Lazy&nbsp;learner?</h2>\n<p>Instance-based learning is also known as memory-based learning<strong>.</strong> Instead of explicit generalization, KNN compares new data samples with training data samples present in its memory.</p>\n<p>They are also called lazy algorithms, as any computation only happens when we receive new observations. Before accepting any test sample, it just memorizes everything in its memory and defers the calculations for the last like a lazy person.</p>\n<h2>Why KNN is a non-parametric algorithm?</h2>\n<p>KNN comes under the <strong><a href=\"https://www.enjoyalgorithms.com/blog/classification-of-machine-learning-models\">non-parametric algorithm</a></strong> category. Can we guess why? It is learning the complete training set, so if there are more instances in the future, the learning will change drastically. Hence learning is not dependent on the given data, which is a characteristic of a non-parametric algorithm.</p>\n<h2>What are the common assumptions in&nbsp;KNN?</h2>\n<p>This algorithm makes two major assumptions,</p>\n<ul>\n<li>Every sample part of the training data is mapped to real n-dimensional space. We can say that every sample will have the same dimension or number of attributes in simple terms.&nbsp;</li>\n<li>The \"nearest neighbors\" are defined in terms of <strong>Euclidean Distance</strong>, <strong>Manhattan Distance</strong>, or <strong>Hamming Distance</strong>. The choice of distance matters a lot and can change the prediction.</li>\n</ul>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/0*MBTyUQ648MfodIMb.png\" alt=\"Distance metrics\" title=\"Distance metrics\"></p>\n<h2><strong>Working of&nbsp;KNN</strong></h2>\n<p>Let's understand the stepwise analysis of this algorithm for any classification problem.</p>\n<p><strong>Step1:</strong> We first need to select the number of neighbors we want to consider. This is the term K in the KNN algorithm and highly affects the prediction.</p>\n<p><strong>Step2: We</strong> need to find the K neighbors based on any distance metric. It can be Euclidean, Manhatten, or our custom distance metric. We will have the test sample on which we want the prediction. The Closest K samples in the training data from this test sample will be our K neighbors.</p>\n<p><strong>Step3:</strong> Among the selected K neighbors, we need to count how many neighbors are from the different classes.&nbsp;</p>\n<p><strong>Step4:</strong> Now, we have to assign the test data sample to the class for which the count of neighbors was maximum.</p>\n<p>We performed the prediction in these four simple steps. In summary, the KNN algorithm at the training phase stores the dataset, and when it gets a new query, it classifies that query into a class similar to the existing query.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*-S8Zf-MufUStk1OEyEzuFQ.jpeg\" alt=\"1-NN vs. 4-NN \" title=\"1-NN vs. 4-NN\"></p>\n<p>Consider an example shown in the above image. Initially, the entire training dataset is considered and mapped in an R² space of positive and negative classes. The test case <strong>xq</strong> is then classified using 1-NN (1 neighbor) and 4-NN (4 neighbors) classifiers. The results for both are different, as we see that <strong>xq</strong> is classified as <strong>+ve for 1-NN</strong> and <strong>-ve for 4-NN.</strong>&nbsp;</p>\n<h2>How the value of K affects the KNN algorithm?</h2>\n<p>The value of K in the KNN algorithm can be anything ranging from 1 to the total number of samples. A small value of K means that the model is overfitting and is vulnerable to outliers. This model will have high variance and low bias. On the other hand, a model with a high value of K will have low variance and high bias and will result in underfitting. When we slowly increase the value of K from 1 to the number of training samples, the model will start smoothing the boundary surfaces.</p>\n<p><strong>K = 1:</strong> A model with K=1 will have 0 training error and hard boundaries for determining the class of test query.</p>\n<p><strong>K = len(sample data):</strong> This model will be highly biased towards the majority class (with a higher number of samples) and less accurate.</p>\n<p><strong>Note:</strong> Keeping the K values as odd is advisable to reduce the chances of getting a tie.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*7yP2rK3WSNvw_rSXecvPnQ.jpeg\"></p>\n<h2>How does feature scaling affect&nbsp;KNN?</h2>\n<p>KNN depends highly on the distance between data samples; hence scaling plays a vital role here. Suppose we train the KNN algorithm on unscaled data. There can be a case where different attributes lie in various scales, making our model biased towards the features with lesser magnitude values. To avoid that, it is always advisable to standardize the attributes before applying the KNN algorithm. Please look at <a href=\"https://www.enjoyalgorithms.com/blog/need-of-feature-scaling-in-machine-learning\">this blog</a> to visualize how distance calculation can be affected by scaling for a better understanding.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/0*-tv0vjTEud6hDKWn.png\" alt=\"Source: Scikit-learn.org, Scaling affect KNN \" title=\"Scaling affect KNN \"></p>\n<h2>What are the Voronoi cell and Voronoi diagrams?</h2>\n<p>Other ML algorithms like linear regression, logistic regression, and SVMs try to fit a mapping function from input to output. This mapping function is also known as the <strong>Hypothesis function</strong>. But, KNN is different. It does not form any explicit Hypothesis function, but it does create a hypothesis space. For a dataset in R², the hypothesis space is a polyhedron formed using the training samples. Let's first understand what Voronoi cell is.</p>\n<h3><strong>What is Voronoi&nbsp;Cell?</strong></h3>\n<p>Suppose the training set is \"T\" and the elements of that training set are \"x\"<strong>.</strong> Then Voronoi Cell of <strong>xi</strong> is a polytope (a geometric shape with \"flat\" sides) consisting of all points closer to <strong>xi</strong> than any other points in <strong>T.</strong></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*vvDVXsv2ulT_-IaikeAXNg.jpeg\" alt=\"Voronoi Cell and polytope\" title=\"Voronoi Cell and polytope\"></p>\n<p>If we observe in the above image, initially, every cell contains a single sample which means K = 0, and as we increase the value of K, two cells merge and form a new polytope including K samples. Voronoi Cells cover the entire training space of T, and when we combine all of these cells, it will create Voronoi Diagram.</p>\n<h2>KNN for Regression problems</h2>\n<p>So far, we have discussed how we could use the KNN algorithm to solve the classification tasks, but this machine learning algorithm can also solve regression problems. We need to tweak the approach slightly. Instead of counting the <strong>K</strong> nearest neighbor class labels, what if we average the data over K neighbors<strong><em>.</em></strong> Yes! It will act as the regression model in such a scenario.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*RWeDQNYq_K3bLqA6K3ni1A.jpeg\">k-NN for Regression tasks</p>\n<p>For example, let's say we have a test data X for which we want to predict the continuous variable Y. Suppose we have finalized that our neighbors can only be 3 (i.e., K=3). Three neighbors from the training data are:</p>\n<p>X1 → Y1, X2 → Y2, X3 → Y3. We should be clear that KNN is a supervised learning algorithm, and hence we will always have the corresponding labels for the input variables while training. At the time of prediction, we can average out the three labels to find the corresponding label of the test data. For example, Y = (Y1 + Y2 + Y3)/3. This averaging can be replaced with other techniques like median, mode, or any custom approach.&nbsp;</p>\n<h2>Strengths of KNN algorithm</h2>\n<p>KNN is a very famous algorithm because of its simplicity, so let's understand the key strengths.&nbsp;</p>\n<ol>\n<li><strong>Zero training time:</strong> A very little training time is required compared to the other machine learning algorithms.</li>\n<li><strong>Sample efficiency:</strong> There is no need for a very high training sample.</li>\n<li><strong>Explainable:</strong> At each step, the reason for the prediction can easily be depicted. Such explainability is rare.</li>\n<li><strong>Easy to add and remove the data:</strong> For other machine learning models, data addition requires retraining of the model. While in KNN, we can directly update the memory and perform the inference.</li>\n<li><strong>Less sensitive to class imbalance:</strong> Suppose we have two classes and one class has significantly higher instances in the dataset than others. KNN, unlike other ML algorithms, is least affected by such class imbalances.</li>\n</ol>\n<h2>Disadvantages of k-NN algorithm</h2>\n<p>No doubt, KNN is cool, but this algorithm has some limitations. It is not the first choice among Machine Learning experts, and the reasons are:</p>\n<ol>\n<li><strong>Needs a lot of storage:</strong> KNN stores the whole training data in its memory and performs inference based on that. It makes the algorithm unemployable on edge platforms.</li>\n<li><strong>Predictions are Slow:</strong> The time complexity of KNN is O(dN), where <strong>d</strong> is the dimension or number of features and <strong>N</strong> is the total number of samples. More the data more will be the prediction time.</li>\n<li><strong>Irrelevant features can fool the nearest neighbors.</strong></li>\n</ol>\n<h2><strong>KNN Implementation in Python using&nbsp;sklearn</strong></h2>\n<p>Too much theory! Let's implement the KNN algorithm in python to solve a classification problem.&nbsp;</p>\n<h3><strong>Step 1: Import the necessary dataset libraries.</strong></h3>\n<p>The dataset used to implement KNN is the famous Iris dataset imported from the Scikit-learn datasets as load_iris. Other libraries are imported for training, preprocessing, and evaluation.</p>\n<pre><code class=\"language-python\">import matplotlib.pyplot as plt   # update the plot \nfrom sklearn import datasets# read the data \nimport numpy as np #for arrays \nfrom sklearn.model_selection import train_test_split # split the data \nfrom sklearn.preprocessing import StandardScaler # scale the data \nfrom sklearn.neighbors import KNeighborsClassifier # the algorithm \n\nfrom sklearn.metrics import accuracy_score  #grade the results \nimport pandas as pd \n\niris = datasets.load_iris() # read the data \n\nX = iris.data[:]  # select the features to use \ny = iris.target   # select the classes\n\n\niris_dataframe = pd.DataFrame (data= np.c_[iris['data'], iris['target']],\n\n    columns= iris['feature_names'] + ['target'])\n\nplt.figure(2)\ngrr = pd.plotting.scatter_matrix(iris_dataframe,\n                                  c=iris[\"target\"], \n                                  figsize=(15, 15),\n                                  marker='o', \n                                  S=60,\n                                  alpha=.8)\nplt.show(2)\n</code></pre>\n<h3>Step 2: Understanding the&nbsp;data</h3>\n<p>This dataset has four variables: <strong>sepal length, sepal width, petal length, and petal width,</strong> describing iris plants of three types: <strong>Setosa, Versicolour,</strong> and <strong>Virginica</strong>. The dataset contains 150 observations, with each observation labeled as the actual type of the plant.&nbsp;</p>\n<h3>Step 3: Visualization</h3>\n<p>The dataset, which has four dimensions, is visualized pairwise to distinguish them. The pairwise scatter plot matrix of the iris data set helps visualize the relationship among multiple variables separately within subdivisions of the dataset. In the image below, <strong>violet</strong> color represents <strong>Setosa</strong>, <strong>green</strong> represents <strong>Versicolour</strong>, and <strong>yellow</strong> represents <strong>Virginica</strong>.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*L4b2d0tYFWeEkcDuajgZyw.jpeg\" alt=\"Pairwise comparison for different features\" title=\"Pairwise comparison for different features\"></p>\n<h3><strong>Step 4: Data Preprocessing</strong></h3>\n<p>The entire dataset is initially split into the training and testing part using the train<em>test</em>split function of Scikit-learn. A standard scaler is used in the next step, StandardScalar( ), to standardize the data (column-wise). When fit to a dataset, the function will transform the dataset to <strong>mean μ = 0</strong> and <strong>standard deviation σ = 1.</strong></p>\n<p>A dataset with having N samples and m features,</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*L_Q44QKznAFWYejvWXyKoQ.png\" alt=\"Distance Calculation\" title=\"Distance Calculation\"></p>\n<p>Thus every data is then updated as,</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*UkLkymXlo54_RbAseOBr1Q.png\" alt=\"Standardization\" title=\"Standardization\"></p>\n<pre><code class=\"language-python\">X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.25,random_state=0)\n\n\nSC = StandardScaler()# create the standard scaler \nsc.fit(X_train) # fit to the training data \nx_train_std = sc.transform(X_train) # transform the training data \nX_test_std = sc.transform(X_test) # same transformation on test data\n</code></pre>\n<h3><strong>Step 5: Model Fitting and Evaluation</strong></h3>\n<p>We will fit the KNN model for different values of K ranging between 1 to the number of samples in the testing dataset. The metric <strong>\"Minkowski\"</strong> along with <strong>p = 2</strong> represents the Euclidean distance in the R-space. The model will be fitted on different values of K and then is used to predict the output for a test sample size.</p>\n<pre><code class=\"language-python\">accuracyTest = {}; accuracy Train = {} \n\nfor k in range (len (y_test):\n\n    knn = KNeighborsClassifier(n_neighbors=k+1, p=2, metric='minkowski')\n    knn.fit(X_train_std,y_train)\n    y_pred = knn.predict(x_test_std) \n    y_train_pred = knn.predict(X_train_std) \n\n    if (k+1)%10==0:\n        print(10*'-')\n        print(\"For k = %s\" %(k+1))\n        print('Number in test ', len(y_test))\n        print('Misclassified samples: %d' % (y_test != y_pred).sum())\n\n    accTrain = accuracy_score(y_train,y_train_pred)\n    acc = accuracy_score(y_test, y_pred)\n    accuracyTest[k+1] = acc\n    accuracyTrain[k+1] = accTrain\n\nfor accuracy in [accuracy Train, accuracy Test]:\n    lists = sorted(accuracy.items() # sorted by key, return a list of tuples \n    X, y = zip(*lists) # unpack a list of pairs into two tuples \n    plt.plot(x, y)\n    plt.show()\n</code></pre>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*2w5zsVeff7Ob1tMp4p8E2Q.png\" alt=\"Training and Testing accuracy\" title=\"Training and Testing accuracy\"></p>\n<p>If we give priority to the testing accuracy, the value of K &gt; 18 decreases the testing accuracy sharply. So we can say that the optimal number of neighbors can be around 15 to 18.</p>\n<h2><strong>Decision Boundaries for&nbsp;KNN</strong></h2>\n<p>The two datasets (training and testing) are combined to show the effect of varying K in the KNN algorithm. Only two features (petal length and petal width) are considered for visualization. The value of K taken is [1,25,50,75,100,112], where the training sample size is 112. The decision boundary at K = 112 returns the majority of the three classes, which is red.</p>\n<pre><code class=\"language-python\">X = iris.data[:, [2,3]] # select the features to use \ny = iris.target         # select the classes\n\nX_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.25,random_state=0)\n\n\nSC = StandardScaler()# create the standard scaler \nsc.fit(X_train) # fit to the training data \nx_train_std = sc.transform(X_train) # transform the training data \nX_test_std = sc.transform(X_test) # same transformation on test data\n\nX_combined_std = np.vstack((X_train_std, X_test_std))\ny_combined = np.hstack((y_train, y_test))\n\nprint('Number in combined ', len(y_combined))\n# check results on combined data \ny_combined_pred = knn.predict(X_combined_std)\n\nprint('Misclassified combined samples: %d' 1 % (y_combined != y combined_pred). sum )\nprint('Combined Accuracy: %.2f' % accuracy_score(y_combined, y_combined_pred)) \n# visualize the results \n\nfor k in [1,25,50, 100, len(X_train)]:\n\n    knn = KNeighborsClassifier (n_neighbors=k, p=2, metric='minkowski')\n\n    knn.fit(X_train_std, y_train) \n\n    plot_decision_regions(X=X_combined_std, y=y_combined, classifier=knn,\n                                test_idx=range(105,150))\n\n    plt.xlabel('petal length [standardized]') \n    plt.ylabel('petal width [standardized]') \n    plt.title('k=%s'%k) \n    plt.legend(loc='upper left') \n    plt.show()\n</code></pre>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*VXDGlFehAYqClSiAbsApSQ.jpeg\" alt=\"Decision boundary\" title=\"Decision boundary\"></p>\n<h2>Industrial Applications of&nbsp;KNN</h2>\n<p>Although there are certain limitations, this algorithm is widely used in industries because of its simplicity. Some of these applications are:</p>\n<ol>\n<li><strong>Email spam filtering:</strong> For detecting the trivial and fixed types of spam emails, KNN can perform well. The implementation steps of this algorithm can be found <a href=\"https://www.enjoyalgorithms.com/blog/email-spam-and-non-spam-filtering-using-machine-learning\">here</a>.</li>\n<li><strong>Wine Quality prediction:</strong> Wine quality prediction is a regression task and can be solved using the KNN algorithm. The implementation can be found <a href=\"https://www.enjoyalgorithms.com/blog/wine-quality-prediction\">here</a>.</li>\n<li><strong>Recommendation system:</strong> KNN is used to build the recommendation engines that recommend some products/movies/songs to the users based on their likings or disliking.&nbsp;</li>\n</ol>\n<h2>Possible Interview Questions</h2>\n<p>As we stated, this algorithm brings a lot of explainability with itself. Interviewers can ask more profound questions on this topic. Some of them could be,</p>\n<ol>\n<li>How k-NN is different from other Machine Learning algorithms?</li>\n<li>Will changing the distance metric affect the classification accuracy?</li>\n<li>Is k-NN highly sensitive to data normalization?&nbsp;</li>\n<li>Why is it a non-parametric algorithm?</li>\n<li>What are the major cons of the k-NN algorithm?</li>\n</ol>\n<h2>Conclusion</h2>\n<p>In this article, we have covered the concept of the first \"Machine Learning\" algorithm, i.e., KNearest Neighbour. We saw how we can define the instances as neighbors and how the value of K affects the predictions. We also discussed why feature scaling played a vital role and learned about the Voronoi Diagram. After that, we discussed the regression use-case of KNN. Finally, we implemented the KNN algorithm on the famous Iris dataset. We hope you enjoyed the article.</p>\n<h4>References</h4>\n<ol>\n<li><a href=\"http://jmlr.csail.mit.edu/papers/v12/pedregosa11a.html\">Scikit-learn: Machine Learning in Python</a>, Pedregosa, <em>et al.</em>, JMLR 12, pp. 2825–2830, 2011</li>\n<li>Mitchell, T. M. (1997). Machine learning., McGraw Hill series in computer science New York: McGraw-Hill.</li>\n<li>UCI Machine Learning Repository: Iris Data Set.</li>\n<li>J. D. Hunter, “Matplotlib: A 2D Graphics Environment”, Computing in Science &amp; Engineering, vol. 9, no. 3, pp. 90–95, 2007.</li>\n</ol>\n<h4>Enjoy Learning! Enjoy Algorithms!</h4></div>",
        "createdAt": "2022-02-24T07:45:46.825Z",
        "updatedAt": "2022-02-26T19:27:02.372Z",
        "publishedAt": "2022-02-24T07:46:12.600Z"
        }
    ]
}